#ifndef SPIDEV_H
#define SPIDEV_H

#include <SPI.h>
#include "buf.h" 
#include "crc8.h"

#define BUF_SIZE 64 

struct s_buf<byte> ibuf; 
struct s_buf<byte> obuf; 

/*
volatile byte SPI_iptr = 0;                                                       
volatile byte SPI_isize = 0;                                                      
unsigned char SPI_ibuf[BUF_SIZE];                                                       
volatile byte SPI_optr = 0;                                                       
volatile byte SPI_osize = 0;                                                      
unsigned char SPI_obuf[BUF_SIZE];                                                       
*/

void SPI_init() {
	buf_init(&ibuf,BUF_SIZE);
	buf_init(&obuf,BUF_SIZE);
}

void SPI_sendBytes(uint8_t *data, byte len) {
    if (buf_space(&obuf)<=len) {
#ifdef DEBUG
        Serial.println("SPI out buf full!");
        //if you decide to wrap the buffer, will need to change firstLoad to load a new byte into reg
#endif
        return;
    } 

    for (int i=0;i<len;i++)
	buf_push(&obuf,data[i]);

    buf_push(&obuf,CRC8((byte*)data,len));

}

int SPI_getPacket(byte *b) {
    //byte c;
    if (ibuf.size<4) return -1;

    for (int i=0;i<4;i++)
	*(b+i) = buf_pop(&ibuf);

    if (CRC8(b,3)!=b[3]) {
	crc_err++;
	buf_clear(&ibuf);
#ifdef DEBUG
        static unsigned int n = 0;
        Serial.print("SPI packet corrupted!!"); Serial.println(n++);
#endif
        return -1;
    }

    return 0;
}

/*
int16_t SPI_getInt16(int *i) {
    if (SPI_isize<2) return -1;                                                    
    byte b1=0,b2=0;
    SPI_getByte(&b1);
    SPI_getByte(&b2);
    return (int16_t)(b2<<8 | b1);
}
*/

ISR (SPI_STC_vect) {                                                             
    byte c = SPDR;   
    
//set output byte
    SPDR = buf_pop(&obuf);

//get input
    buf_push(&ibuf,c);
} 
#endif

